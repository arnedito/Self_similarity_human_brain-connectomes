! PROGRAM TO OBTAIN THE DEGREE LIST AND NEIGHBOUR LIST SEPARATELY GIVEN AN UNDIRECTED AND UNWEIGHTED NETWORK'S EDGELIST
       PROGRAM EDGELIST
       IMPLICIT NONE
       INTEGER*8 I,J,N,NODE,SUM,K,EDGES,LINE,IOSTATUS
       INTEGER, ALLOCATABLE :: DEGREE(:), NEIGHBOURS(:)
       INTEGER, POINTER :: HEAD(:), COUNT(:)
       
! INTRODUCE THE NUMBER OF NODES OF THE NETWORK
       NODE = 1014


       EDGES = 0 !INITIALIZE TO CALCULATE NUMBER OF LINKS
       SUM = 0 !SUM OF DEGREES

       ALLOCATE(DEGREE(NODE))
       DEGREE = 0
    
! ABRIMOS EL ARCHIVO DE UL/HCP DATASET
       OPEN(11, FILE = "UL_nobrainstem_10_layer_0_edgelist.txt")

! CALCULAMOS LAS FILAS DE LA EDGE LIST (NUMERO DE CONNEXIONES)
       DO
        READ(11, *, IOSTAT = IOSTATUS) LINE ! LEEMOS LINEA DEL ARCHIVO
        IF (IOSTATUS /= 0) EXIT !SI LLEGA AL FINAL DEL ARCHIVO QUE SALGA
        EDGES = EDGES + 1
       ENDDO

! EL VALOR DE EDGES SERA MAYOR AL NUMERO DE CONNEXIONES QUE HAY PERO AL AÑADIR UNA VARIABLE DE CONTROL NO HAY PROBLEMA CON ESO
       CLOSE(11)
       OPEN(11, FILE = "UL_nobrainstem_10_layer_0_edgelist.txt")
        
! CALCULAMOS EL VECTOR QUE CONTIENE LOS GRADOS
       DO N = 1, EDGES
        READ(11, *, IOSTAT = IOSTATUS) I,J
        IF (IOSTATUS /= 0) THEN
            WRITE(*,*) 'ERROR AL LEER LA EDGE LIST EN LA FILA ', N
            WRITE(*,*) I, J
            EXIT
        ENDIF
        IF (I /= J) THEN
            DEGREE(I+1) = DEGREE(I+1) + 1 !SUMAMOS 1 YA QUE EL PRIMER NODO ES 0
        ENDIF
       ENDDO
       
       CLOSE(11)

       OPEN(12, FILE = "degrees0.txt")
!ESCRIBIMOS LOS GRADOS EN UN ARCHIVO DE TEXTO
       DO N = 1, NODE
        SUM = SUM + DEGREE(N)
        WRITE(12,'(I0,3X,I0)') (N-1), DEGREE(N)
       ENDDO

       CLOSE(12)

       WRITE(*,*) 'LAYER 0'
       WRITE(*,*) 'Suma de los degrees: ', SUM
       WRITE(*,*)'<k> = ',DBLE(SUM)/NODE

!--------------------------------------------------------------------------------------
! NEIGHBOR VECTOR


! DEFINIMOS LA DIMENSIONALIDAD DEL VECTOR Y LOS PUNTEROS
       ALLOCATE(NEIGHBOURS(SUM))
       ALLOCATE(HEAD(NODE+1))
       ALLOCATE(COUNT(NODE+1))
     
       NEIGHBOURS = 0
    
! RELLENAMOS EL PUNTERO HEAD() EN EL CUAL CADA POSICION SERA EL GRADO POR EL QUE EMPEZARÁN A CONTAR LOS VECINOS DE CADA NODO
! INICIALIZAMOS EL PUNTERO COUNT(), SERVIRÁ PARA CONTROLAR EN QUE POSICION DEL VECTOR V COLOCAR AL VECINO CORRESPONDIENTE.
       HEAD(1) = 1
       COUNT(1) = 1
        
       DO I = 2, NODE+1
        HEAD(I) = HEAD(I-1) + DEGREE(I-1)
        COUNT(I) = 1
       ENDDO

       OPEN(71, FILE = "UL_nobrainstem_10_layer_0_edgelist.txt")

!CALCULAMOS EL VECTOR V RELLENANDO A MEDIDA QUE ENCONTRAMOS LOS VECINOS, SUMAMOS 1 YA QUE EL PRIMER NODO ES EL 0 Y LA POSICIÓN 0 NO EXISTE
       DO K = 1,EDGES
        READ(71,*,IOSTAT = IOSTATUS) I,J
        IF (IOSTATUS /= 0) EXIT
! AÑADIMOS LOS VECINOS SI NO HAY SELF LOOPS
        IF (I /= J) THEN
            NEIGHBOURS(HEAD(I+1)+COUNT(I+1)-1) = J
            COUNT(I+1) = COUNT(I+1) + 1
        ENDIF
       ENDDO
       CLOSE(71)

       OPEN(87, FILE = 'neighbours0.txt')
       
! ESCRIBIMOS EL VECTOR V EN UN ARCHIVO
       DO K = 1,SUM
        WRITE(87,'(I0)') NEIGHBOURS(K)
       ENDDO

       CLOSE(87)
       ENDPROGRAM EDGELIST
